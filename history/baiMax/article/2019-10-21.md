webpack 是什么，有什么用，未来如何
1-1：创建文件，初始化项目
npm init --> 生成 package.json 文件 （npm init -y 会默认使用配置，不用去选择）
{
  "name": "demo1", 
  "version": "1.0.0",
  "description": "",
  "private": true,   //项目私有化
  "author": "byf",
  "license": "ISC" 
}
安装webpack （不推荐全局，因为项目有不同版本项目等一系列原因）
安装 npm install webpack webpack-cli -g (全局安装)
卸载 npm uninstall webpack webpack-cli -g (全局卸载)

项目里安装 webpack: npm install webpack webpack-cli  -D (-save-dev 的简写)
现在使用 webpack -v 查询不到 webpack 版本
因为全局没有了 webpack  我们需要借助 node 的 npx 查看 webpack版本号
npx webpack -v (npx命令会帮助我们去node_modules下去查找模块包)

npx： 查询项目内模块包的版本

番外：
npm info webpack  查询包的版本 
npm install webpack@4.26.0 webpack-cli -D 和安装固定版本包 
把自己的项目拷贝给别人的时候，把 node_modules 删除 然后在 npm i 安装

小结：以上我们学会了初始化一个项目以及配置不同版本的 webpack 还有node的命令，以及全局安装webpack带来的问题

1-2： webpack 的配置文件
文件名：webpack.congif.js (固定文件名)
番外命令：npx webpack --config wpCnfig.js  // 以wpConfig 配置文件打包

webpack.congif.js 配置文件代码（webpack有默认的配置文件，不写他会按默认的来执行）：
// 引入 node 的 path 模块配合
const path = require('path')
// 原始打包
module.exports = {
  entry: './index.js', // 从index.js 打包 项目打包的入口文件
  output: {
    filename: 'bundle.js',   // 打包生成文件名
    path: path.resolve(__dirname, 'bundle')  //打包的路径（后跟绝对路径）
  }
}

代码结构优化：
原则： 浏览器直接运行的代码和不能直接运行的代码（源代码）分开存放
源代码存放在 src 目录下 以及 webpack.congif.js 的配置需要修改 
（待扩展，文件目录结构划分）
首先，我们稍微调整下目录结构，将“源”代码(/src)从我们的“分发”代码(/dist)中分离出来。
“源”代码是用于书写和编辑的代码。
“分发”代码是构建过程产生的代码最小化和优化后的“输出”目录，最终将在浏览器中加载：

小结：三种打包方式
全局： global 
webpack index.js

局部：local
npx webpack index.js

借助 npm script 
npm run bundle  ==> webpack (因为 webpack.config.js 配置的打包文件，省略了 index.js)

三种方式，归根结底，都是去运行 webpack 命令
番外：我们之所以能在命令行里运行 webpack 命令 是因为 webpack-cli 的功劳
webpack-cli的作用：使命令行里能正常运行 webpack 命令

以上我们学会了如何配置 webpack.config.js 文件 修改打包文件名以及打包路径。
以上内容对应官网： 中文文档 -> 指南 -> 起步内容

loader学习：js 以外的模块需要 loader 辅助打包
loader的执行顺序 从下到上，从左到右
webpack 默认知道打包js模块，但是不知道 jpg 等其他文件怎么打包。所以我们需要配置 loader 辅助 webpack 打包
file-loader ：打包流程。就是把文件中到静态文件添加 入 dist 文件 同时 获得返回文件地址 
打包流程：遇到 jpg 文件时候 会被移动到 dist 目录下 名字需要自定义 默认为hash值。
url-loader: 图片转码成 base-64 字符串。直接放到 main.js 中

好处：一次性加载js 不需要多余的http请求
坏处：图片过大。js文件也就大。加载缓慢，
处理方法：use 下 options下添加 limit 属性
limit：2048 
表示 文件最大为2048（2kb）,不超过就以base64形式，超过就和file-loader 一样到打包模式打包

问题1: js 文件 import 和 require 导出的对象不同，why？
问题2: webpack.config.js 文件中 file-loader 配置name属性成方法，如何拿到 webpack.config.js  的mode

样式文件打包
（配置参考官方 https://www.webpackjs.com/loaders/url-loader/ 可以一步一步实现）
style-loader: 把样式挂在到html头部标签，

css-loader: 需要配置 options 里的 importLoader: 2 (在index.js中 import 别的css文件的时候再次执行其他loader，如果不设置，在index.js 再次引入别的样式文件，不会执行之前的sass等loader)

sass-loader: (需要装sass）
postcss-loader: 自动添加 css3属性的厂商前缀 

模块化的 css  类似vue 的style scoped

打包字体文件(直接打包到dist中)
使用 file-loader 
阅读官网 Guides 下 Asset Management  css-loader sass-loader 等loader 查阅



webpack 之插件（plugin）:想在打包的过程中做什么事情就加对应的plugin
1、插件需要引入(require)
2、像vue的生命周期函数，会在特定的时刻，帮你做一些事情
3、

htmlWebpackPlugin:打包之后运行 插件会在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中
clean-webpack-plugin: 打包之前运行 删除之前打包的dist 
https://blog.csdn.net/qq_23521659/article/details/88353708

entry 与 output 打包多个文件时候的配置

3-7
属性：devtool 
webpack.config.js 导出模块中的 devtool 属性
选项意义：此选项控制是否生成，以及如何生成 source map。
解决的问题：没有配置时，打包出来的代码出错了，并不知道源代码出错在哪。配置后能定位到源代码出错的位子。
api连接：https://www.webpackjs.com/configuration/devtool/
devtool: 'source-map'
source-map: 打包后的代码和打包前的代码形成映射关系
ex：打包后的代码 main.js 90行报错，对应的开发代码是第一行。这个映射关系由 source-map 帮我们实现

inline 开头的会把 map 文件内置到 main.js 里面去（使得 main.js比较大）
eval 以 eval 语法的方式进行打包
module：可以检测到 loader 的错误

mode: development
开发环境建议使用：cheap-module-eval-source-map 
优点：错误提示比较全面，打包速度比较快

mode: production
线上代码建议使用：cheap-module-source-map
优点：打包速度快，有简介到映射对照（代码线上环境了。可以不用太详细到对照）

3-8
简化开发的方式：
package.json 中 scripts 配置 "watch": "webpack --watch",
功能：能监听到我们代码改变自动打包。（不能帮我启动服务器）

webpack devServer：
隐藏特性：打包生成的 dist 目录放在了电脑内存里面，有效提升打包速度和提高开发效率
1、需要配置 package.json 和 webpack.config.js
package.json 中
"scripts": {
    "dev-build": "webpack --config ./build/webpack.dev.js",
    "dev": "webpack-dev-server --config ./build/webpack.dev.js",
    "build": "webpack --config ./build/webpack.prod.js"
}
webpack.config.js 的导出对象中配置
自动打开浏览器 启动服务器地址
devServer:{
    contentBase: './dist',
    open:true,
    port: 8080,
    hot:true,
    hotOnly:true
    // proxy:{
    //   './api': 'http://locahost:1234'
    // }
},
2、功能：自动打开浏览器,能打开服务器，发送ajax请求
https://www.webpackjs.com/configuration/dev-server/#devserver
核心：devServer 属性：
一些框架的cli工具基本都配置了 webpack devServer 使用代理等

webpack 两种使用方式：node 和 命令行


3-9
HMR：热模块替换（修改了哪个模块，哪个模块就更新，其他模块不变）
webpack自带的插件。主要是在开发环境使用。大大提高开发效率
https://www.webpackjs.com/guides/hot-module-replacement/
隐藏知识：css-loader 底层帮我们实现了热模块替换

3-11 babel 使用 （高级开发工程师需要深入学习研究）
两种配置方案：开发环境（业务代码） 和 内库环境（组件代码）
https://babeljs.io/setup#installation
原因：语法没有经过降级兼容处理，低版本浏览器会报错和不兼容。
使用babel实现框架源码，一步一步转化成浏览器源码
使用：参数非常多，使用也非常广（后期学习）
@babel/core: 打通与webpack的连接
@babel/preset-env: 帮助语法降级 部分es6 转化为es5 的翻译规则（没安装只是打通。语法并没有降级）
@babel/polyfill: 在index.js import中引入，补充es6的api （兼容带来的后果是打包后main.js变的很大）
(useBuiltIns参数使用 缺点：会以全局变量的形式翻译)
优化处理：只打包用到的新语法
webpack.config.js 配置中的 module
module: {
  rules:[
    {
      test:/\.js$/,
      exclude:/node_modules/, // 排除node_modules 检测
      loader:"babel-loader",
      //配置打包后的内容
      options:{
        presets:[["@babel/preset-env",{
          targets:{
            chrome: '67', //项目打包运行在的版本
          },
          useBuiltIns: 'usage' //优化处理：只打包用到的新语法 （帮我做了个处理，不用自己引入 babel/polyfill 了）
        }]]
      }
    },
  ]
}
当只是写业务代码时候以上配置就够了。但是写内部库当时候，需要以下配置


插件：@babel/plugin-transform-runtime 相关的配置（有效避免@babel/polyfill全局污染的问题）
corejs 属性值为 2 的时候需要 npm 对应的包。
https://babel.docschina.org/docs/en/babel-plugin-transform-runtime

{
  "plugins": [["@babel/plugin-transform-runtime",{
    "corejs": 2,
    "helpers": true,
    "regenerator": true,
    "useESModules": false
  }]]
}

因为 babel 配置的 options 文件很大。我们可以抽离出来，
抽离过程：
1、在根目录下创建 .babelrc 文件
2、把 webpack.config.js 文件中 babel配置的 options（对象）代码放入
3、删除 webpack.config.js 文件中 babel 配置的 options
以上就完成了抽离。

**章节总结 webpack.config.js 参数说明

module.exports  = {
  //开发环境下进行打包，代码不会被压缩
  mode:'development',
  //打包后的代码错误和开发代码映射
  devtool:'cheap-module-eval-source-map',
  // 入口文件配置
  entry: {
    main:'./src/index.js',
    // 二次打包()
    // sub:'./src/index.js'
  },
  // 自动打开浏览器 启动服务器地址
  devServer:{
    //在dist目录下启动服务器
    contentBase: './dist',
    open:true,
    port: 8080,
    hot:true,
    hotOnly:true
    // proxy:{
    //   './api': 'http://locahost:1234'
    // }
  },
  //遇到不同文件和模块类型的时候，使用对应的规则打包
  module: {
    rules:[
      {
        test:/\.js$/,
        exclude:/node_modules/, // 不检测node_modules
        loader:'babel-loader',
        // options
        // options:{
        //   // 业务代码配置 需要在index.js import "@babel/polyfill"
        //   // presets:[["@babel/preset-env",{
        //   //   targets:{
        //   //     chrome: '67', //项目打包运行在的版本
        //   //   },
        //   //   useBuiltIns: 'usage' //优化处理：只打包用到的新语法
        //   // }]]

        //   // 内库代码配置(polyfill会污染全局变量)
        //   "plugins": [["@babel/plugin-transform-runtime",{
        //     "corejs": 2,
        //     "helpers": true,
        //     "regenerator": true,
        //     "useESModules": false
        //   }]]
        // }
      },
      {
      test:/\.(jpg|png|gif)$/,
      use:{
        loader: 'url-loader',
        options:{
          // 配置打包名字和后缀
          // placeholder 暂位符
          name:'[name]_[hash].[ext]',
          // 可以配置成函数
          // name(file){
          //   console.log(file)
          //   if (this.mode === 'development') return '[path][name].[ext]'
          //   return '[hash].[ext]'
          // },
          outputPath:'./images', 
          limit: 2048
        }
      }
    },
    {
      test:/\.scss$/,
      use:[
        'style-loader',
        {
          loader:'css-loader',
          options:{
            importLoaders:2,
            // modules: true
          }
        },
        'sass-loader',
        'postcss-loader'
      ]
    },
    {
      test:/\.css$/,
      use:[
        'style-loader',
        'css-loader',
        'postcss-loader'
      ]
    },
    {
      test:/\.(eot|woff|ttf|svg)$/,
      use:{
        loader:'file-loader',
        options:{
          name:'[name]_[hash].[ext]',
          outputPath:'./font', 
        }
      },
    }
  ]
  },
  plugins:[
    new HtmlWebpackPlugin({template:'./src/index.html'}),
    // new CleanWebpackPlugin(['dist']),
    new webpack.HotModuleReplacementPlugin()
  ],
  //打包对应的配置filename 的 name 对应 入口文件的名字
  output: {
    // publicPath:'/',
    // name 对应 entry 的 key 值
    filename: '[name].js',   // 打包生成文件名
    path: path.resolve(__dirname, 'dist')  //打包的路径（后跟绝对路径）
  },
} 


4-1 Tree Shaking
Tree Shaking: 把一个模块里用不到的东西都摇晃掉（用啥加载啥）
Tree Shaking 只支持 ES(import) Module（ 静态引入不支持 commonjs 的 require）
如何实现 Tree Shaking

webpack.config.js 导出对象中添加
 // 哪些导出的模块被导出了，会被打包
optimization:{
  usedExports: true
},
package.json 中添加 
"sideEffects": false, 

注意点：当我们在 index.js 中 import '@babel/polly-fill'的时候。
他并没有导出任何东西。而是在 window 对象上添加了 window.Promise 等属性，
这里我们需要做特殊的设置 这时候就用到了sideEffects 配置，把需要用的填入 "sideEffects": ["@babel/polly-fill"], 
这样 Tree Shaking 的规则就不会作用于 @babel/polly-fill 了

Tree Shaking 在 mode 为 production（线上环境） 的时候才会生效

4-2 development 和 Production 模式的区分打包
开发环境下使用 development 模式:
优势：代码不经过压缩处理，报错导航全面source-map更加明确，快速定位代码问题
线上环境使用 production
优势：代码经过了压缩处理。体积小 source-map更加简洁

配置线上环境和开发环境：
1、把webpack.config.js文件拆分 
开发：webpack.dev.js 
线上：webpack.prod.js 线上环境去掉的代码。服务器配置等代码

优化：开发和线上配置存在着许多等重复代码，我们需要做一些处理
创建 webpack.common.js 文件抽离代码
引入模块：npm i webpack-merge -D

4-3 webpack 和 code splitting (代码分割)

import _ from 'lodash';
当我们直接引用 lodash 库的时候，假设有1mb 业务代码有1mb
main.js 打包文件会很大，加载时间长，（加载2mb）
重新访问我们的页面的时候，又要加载2mb的文件，
解决思路把库挂载到全局 windos上 打包入口文件添加 lodash 打包
这样两个js文件就会并行加载，可以提升加载效率