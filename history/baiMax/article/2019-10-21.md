webpack 是什么，有什么用，未来如何
1-1：创建文件，初始化项目
npm init --> 生成 package.json 文件 （npm init -y 会默认使用配置，不用去选择）
{
  "name": "demo1", 
  "version": "1.0.0",
  "description": "",
  "private": true,   //项目私有化
  "author": "byf",
  "license": "ISC" 
}
安装webpack （不推荐全局，因为项目有不同版本项目等一系列原因）
安装 npm install webpack webpack-cli -g (全局安装)
卸载 npm uninstall webpack webpack-cli -g (全局卸载)

项目里安装 webpack: npm install webpack webpack-cli  -D (-save-dev 的简写)
现在使用 webpack -v 查询不到 webpack 版本
因为全局没有了 webpack  我们需要借助 node 的 npx 查看 webpack版本号
npx webpack -v (npx命令会帮助我们去node_modules下去查找模块包)

npx： 查询项目内模块包的版本

番外：
npm info webpack  查询包的版本 
npm install webpack@4.26.0 webpack-cli -D 和安装固定版本包 
把自己的项目拷贝给别人的时候，把 node_modules 删除 然后在 npm i 安装

小结：以上我们学会了初始化一个项目以及配置不同版本的 webpack 还有node的命令，以及全局安装webpack带来的问题

1-2： webpack 的配置文件
文件名：webpack.congif.js (固定文件名)
番外命令：npx webpack --config wpCnfig.js  // 以wpConfig 配置文件打包

webpack.congif.js 配置文件代码（webpack有默认的配置文件，不写他会按默认的来执行）：
// 引入 node 的 path 模块配合
const path = require('path')
// 原始打包
module.exports = {
  entry: './index.js', // 从index.js 打包 项目打包的入口文件
  output: {
    filename: 'bundle.js',   // 打包生成文件名
    path: path.resolve(__dirname, 'bundle')  //打包的路径（后跟绝对路径）
  }
}

代码结构优化：
原则： 浏览器直接运行的代码和不能直接运行的代码（源代码）分开存放
源代码存放在 src 目录下 以及 webpack.congif.js 的配置需要修改 
（待扩展，文件目录结构划分）
首先，我们稍微调整下目录结构，将“源”代码(/src)从我们的“分发”代码(/dist)中分离出来。
“源”代码是用于书写和编辑的代码。
“分发”代码是构建过程产生的代码最小化和优化后的“输出”目录，最终将在浏览器中加载：

小结：三种打包方式
全局： global 
webpack index.js

局部：local
npx webpack index.js

借助 npm script 
npm run bundle  ==> webpack (因为 webpack.config.js 配置的打包文件，省略了 index.js)

三种方式，归根结底，都是去运行 webpack 命令
番外：我们之所以能在命令行里运行 webpack 命令 是因为 webpack-cli 的功劳
webpack-cli的作用：使命令行里能正常运行 webpack 命令

以上我们学会了如何配置 webpack.config.js 文件 修改打包文件名以及打包路径。
以上内容对应官网： 中文文档 -> 指南 -> 起步内容

loader学习：js 以外的模块需要 loader 辅助打包
loader的执行顺序 从下到上，从左到右
webpack 默认知道打包js模块，但是不知道 jpg 等其他文件怎么打包。所以我们需要配置 loader 辅助 webpack 打包
file-loader ：打包流程。就是把文件中到静态文件添加 入 dist 文件 同时 获得返回文件地址 
打包流程：遇到 jpg 文件时候 会被移动到 dist 目录下 名字需要自定义 默认为hash值。
url-loader: 图片转码成 base-64 字符串。直接放到 main.js 中

好处：一次性加载js 不需要多余的http请求
坏处：图片过大。js文件也就大。加载缓慢，
处理方法：use 下 options下添加 limit 属性
limit：2048 
表示 文件最大为2048（2kb）,不超过就以base64形式，超过就和file-loader 一样到打包模式打包

问题1: js 文件 import 和 require 导出的对象不同，why？
问题2: webpack.config.js 文件中 file-loader 配置name属性成方法，如何拿到 webpack.config.js  的mode

样式文件打包
（配置参考官方 https://www.webpackjs.com/loaders/url-loader/ 可以一步一步实现）
style-loader: 把样式挂在到html头部标签，

css-loader: 需要配置 options 里的 importLoader: 2 (在index.js中 import 别的css文件的时候再次执行其他loader，如果不设置，在index.js 再次引入别的样式文件，不会执行之前的sass等loader)

sass-loader: (需要装sass）
postcss-loader: 自动添加 css3属性的厂商前缀 

模块化的 css  类似vue 的style scoped

打包字体文件(直接打包到dist中)
使用 file-loader 
阅读官网 Guides 下 Asset Management  css-loader sass-loader 等loader 查阅



webpack 之插件（plugin）:想在打包的过程中做什么事情就加对应的plugin
1、插件需要引入(require)
2、像vue的生命周期函数，会在特定的时刻，帮你做一些事情
3、

htmlWebpackPlugin:打包之后运行 插件会在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中
clean-webpack-plugin: 打包之前运行 删除之前打包的dist

entry 与 output 打包多个文件时候的配置

3-7
属性：devtool 
解决的问题：没有配置时，打包出来的代码出错了，并不知道源代码出错在哪。配置后能定位到源代码出错的位子。
https://www.webpackjs.com/configuration/devtool/
devtool: 'source-map'
sourceMap: 代码映射，打包后的代码和打包前的代码
ex：打包后的代码 main.js 90行报错，对应的开发代码是第一行。这个关系由 sourceMap 帮我们实现

inline 开头的把map文件内置打破main.js里面去
eval 以 eval 的方式进行打包
module：可以检测到 loader 的错误

development
开发环境建议使用：cheap-module-eval-source-map 
错误提示比较全面，打包速度比较快

线上代码：cheap-module-source-map

3-8
简化开发的方式：
package.json中 scripts 配置 "watch": "webpack --watch",
功能：能监听到我们代码改变自动打包。（不能帮我启动服务器）

webpack devServer：
隐藏特性：打包生成的dist目录放在了电脑内存里面，有效提升打包速度和提高开发效率
1、需要配置package.json 和 webpack.config.js
2、功能：自动打开浏览器,能打开服务器，发送ajax请求
https://www.webpackjs.com/configuration/dev-server/#devserver
核心：devServer 属性：
一些框架的cli工具基本都配置了 webpack devServer 使用代理等

webpack 两种使用方式：node 和命令行


3-9
HMR：热模块替换

